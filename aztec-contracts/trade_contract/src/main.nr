mod agreement_terms_note;

contract Trade {
    use dep::aztec::{
        context::{PrivateContext, PublicContext, Context},
        hash::{compute_secret_hash},
        state_vars::{map::Map, public_state::PublicState, set::Set},
        protocol_types::type_serialization::FIELD_SERIALIZED_LEN,
        protocol_types::type_serialization::AZTEC_ADDRESS_SERIALIZED_LEN,
        log::emit_encrypted_log,
    };

    //use dep::compressed_string::{FieldCompressedString, FieldCompressedStringSerializationMethods};

    use dep::aztec::oracle::{
    get_public_key::get_public_key,
    };

    use dep::std::option::Option;

    use dep::aztec::note::{
         note_getter_options::{NoteGetterOptions, Comparator},
         note_header::NoteHeader,
         utils as note_utils,
         note_viewer_options::{NoteViewerOptions},
         note_getter::{get_notes, view_notes},
    };

    use dep::aztec::protocol_types::{
        abis::function_selector::FunctionSelector,
        address::AztecAddress,
        grumpkin_point::GrumpkinPoint,
        constants::MAX_NOTES_PER_PAGE,
        };

    use crate::agreement_terms_note::{Agreement_Terms, AGREEMENT_TERMS_SERIALIZED_LEN};

    // Storage structure, containing all storage, and specifying what slots they use.
    struct Storage {
        Products: Map<Field, PublicState<AztecAddress>>,
        AgreementSet: Set<Agreement_Terms>,
    }

    //struct function to push elements stored in Products
    //to view if for everyone in seeProducts
    struct ProductInfo {
        suppliedProduct: Field,
        supplier: AztecAddress,
    }

    impl Storage {
        fn init(context: Context) -> Self {
            Storage {
                Products: Map::new(
                    context,
                    1,
                    |context, slot| {
                        PublicState::new(
                            context,
                            slot
                        )
                    },
                ),
                AgreementSet: Set::new(context, 2),
            }
        }
    }

    // Constructs the contract.
    #[aztec(private)]
    fn constructor() {
    }

    ///////PUBLIC FUNCTIONS///////

   //function to store products in Products
    #[aztec(public)]
    fn storeProduct(suppliedProduct: Field) {
        let supplier = context.msg_sender();
        storage.Products.at(suppliedProduct).write(supplier);
    }

    /////PRIVATE FUNCTIONS//////

    //Erlaubt DEMANDER eine ANFRAGE and supplier zu schicken
    // D.h. demander wird mit msg_sender übernommen
    // supplier wird eingetragen (vorher aus einer öffentlichen Tabelle entnommen)
    #[aztec(private)]
    fn agreement_terms_demanded(
        ProductID: Field,
        PricePerUnit: Field,
        DeliverAmount: Field,
        TotalPrice: Field,
        DeliverDate: Field,
        randomness: Field,
        supplied_by: AztecAddress,
        //demanded_by: AztecAddress,
    ) {
        let owner = context.msg_sender(); //done for the nullifier to be generated by this address
        let demanded_by = context.msg_sender();
        let agreement_terms = storage.AgreementSet;
        let mut note = Agreement_Terms::new(
            ProductID as Field,
            PricePerUnit as Field,
            DeliverAmount as Field,
            TotalPrice as Field,
            DeliverDate as Field,
            randomness as Field,
            owner,
            supplied_by,
            demanded_by,
        );

        agreement_terms.insert(&mut note, true);

        let context = agreement_terms.context.private.unwrap();
        let a_contract_address = context.this_address();
        let encryption_pub_key = get_public_key(supplied_by); //Hier wird die Sichterlaubnis für supplied_by geschaffen
        let encrypted_data = note.serialize_content();


        //In a future version, encryption keys will be differentiated between incoming and outgoing.
        //When sending a note to another user, the sender will use the recipient's incoming encryption key for encrypting the data for them,
        //and will optionally use their own outgoing encryption key for encrypting any data about the destination of that not
        emit_encrypted_log(
                context,
                a_contract_address,
                agreement_terms.storage_slot,
                Agreement_Terms::get_note_type_id(),
                encryption_pub_key,
                encrypted_data,
            );
    }

    ///////Unconstrained FUNCTIONS///////

    //Function to see Products in the list depending on the index
    //Not very elegant -> better with vectors but buts right now
    // see stored links
    unconstrained fn seeProducts(suppliedProduct: Field) -> pub ProductInfo {
       let supplier = storage.Products.at(suppliedProduct).read();
       ProductInfo {supplier, suppliedProduct}
    }

    unconstrained fn readDemands(address: AztecAddress) -> pub [Option<Agreement_Terms>; 10] {
        let options = NoteViewerOptions::new().select(7, address.to_field(), Option::none()); //Sucht addressen aus Speicherplatz 8 //no comparator is euqivalent to equal
        let notes = storage.AgreementSet.view_notes(options);
        notes
    }

    unconstrained fn compute_note_hash_and_nullifier(
        contract_address: AztecAddress,
        nonce: Field,
        storage_slot: Field,
        note_type_id: Field,
        serialized_note: [Field; AGREEMENT_TERMS_SERIALIZED_LEN]
    ) -> pub [Field; 4] {
        let note_header = NoteHeader::new(contract_address, nonce, storage_slot);
        note_utils::compute_note_hash_and_nullifier(Agreement_Terms::deserialize_content, note_header, serialized_note)
    }
}
